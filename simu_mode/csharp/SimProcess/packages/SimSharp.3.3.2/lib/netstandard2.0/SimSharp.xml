<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimSharp</name>
    </assembly>
    <members>
        <member name="P:SimSharp.Report.Output">
            <summary>
            Gets or sets the output target.
            </summary>
            <remarks>
            This is not thread-safe and must be set only when the simulation is not running.
            </remarks>
        </member>
        <member name="M:SimSharp.Report.WriteHeader">
            <summary>
            Writes the header manually to <see cref="P:SimSharp.Report.Output"/>. This may be useful if
            headers are not automatically added.
            </summary>
        </member>
        <member name="M:SimSharp.Report.Update">
            <summary>
            Performs a manual update. It must only be called when manual update is chosen.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when calling this function in another update mode.</exception>
        </member>
        <member name="M:SimSharp.Report.CreateBuilder(SimSharp.Simulation)">
            <summary>
            Creates a new report builder for configuring the report. A report can be generated by
            calling the builder's <see cref="M:SimSharp.Report.Builder.Build"/> method.
            </summary>
            <param name="env">The simulation environment for which a report should be generated.</param>
            <returns>The builder instance that is used to configure a new report.</returns>
        </member>
        <member name="T:SimSharp.Report.Builder">
            <summary>
            The Builder class is used to configure and create a new report.
            </summary>
        </member>
        <member name="M:SimSharp.Report.Builder.#ctor(SimSharp.Simulation)">
            <summary>
            Creates a new builder for generating a report.
            </summary>
            <param name="env">The simulation environment for which the report should be generated.</param>
        </member>
        <member name="M:SimSharp.Report.Builder.Add(System.String,SimSharp.INumericMonitor,SimSharp.Report.Measures)">
            <summary>
            Adds a new indicator to the report.
            </summary>
            <param name="name">The name of the indicator for which the statistic is created.</param>
            <param name="statistics">The statistics instance for the indicator that contains the values.</param>
            <param name="measure">The measure(s) that should be reported.</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="name"/> is null or empty,
            or when <paramref name="measure"/> is not valid.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="statistics"/> is null.</exception>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetAutoUpdate(System.Boolean)">
            <summary>
            In automatic updating mode (default), the report will listen to the
            <see cref="E:SimSharp.IMonitor.Updated"/> event and perform an update whenever
            any of its statistics is updated.
            </summary>
            <remarks>Auto update is mutually exclusive to the other update modes.
            Auto update with headers is the default.</remarks>
            <param name="withHeaders">Whether the headers should be output before the first values are printed.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetManualUpdate(System.Boolean)">
            <summary>
            In manual updating mode, the <see cref="M:SimSharp.Report.Update"/> method needs to be called
            manually in order to record the current state.
            </summary>
            <remarks>Manual update is mutually exclusive to the other update modes.</remarks>
            <param name="withHeaders">Whether the headers should be output before the first values are printed.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetPeriodicUpdate(System.TimeSpan,System.Boolean)">
            <summary>
            In periodic updating mode, the report will create a process that periodically
            triggers the update. The process will be created upon calling <see cref="M:SimSharp.Report.Builder.Build"/>.
            </summary>
            <remarks>Periodic update is mutually exclusive to the other update modes.</remarks>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="interval"/> is less or equal than TimeSpan.Zero.</exception>
            <param name="interval">The interval after which an update occurs.</param>
            <param name="withHeaders">Whether the headers should be output before the first values are printed.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetPeriodicUpdateD(System.Double,System.Boolean)">
            <summary>
            In periodic updating mode, the report will create a process that periodically
            triggers the update. The process will be created upon calling <see cref="M:SimSharp.Report.Builder.Build"/>.
            </summary>
            <remarks>Periodic update is mutually exclusive to the other update modes.</remarks>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="interval"/> is less or equal than 0.</exception>
            <param name="interval">The interval after which an update occurs.</param>
            <param name="withHeaders">Whether the headers should be output before the first values are printed.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetFinalUpdate(System.Boolean)">
            <summary>
            In final update mode, the report will only update when the simulation terminates correctly.
            This is useful for generating a summary of the results.
            </summary>
            <remarks>Final update is mutually exclusive to the other update modes.</remarks>
            <param name="withHeaders">Whether the headers should be output together with the summary at the end.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetTimeAPI(System.Boolean)">
            <summary>
            Whether to output the time column in DateTime format or as double (D-API).
            </summary>
            <param name="useDApi">Whether the time should be output as double.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetOutput(System.IO.TextWriter)">
            <summary>
            Redirects the output of the report to another target.
            By default it is configured to use stdout.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="output"/> is null.</exception>
            <param name="output">The target to which the output should be directed.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.SetSeparator(System.String)">
            <summary>
            Sets the separator for the indicators' values.
            </summary>
            <param name="seperator">The string that separates the values.</param>
            <returns>This builder instance.</returns>
        </member>
        <member name="M:SimSharp.Report.Builder.Build">
            <summary>
            Creates and initializes the report. After calling Build(), this builder instance
            is reset and can be reused to create a new report.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when no indicators have been added.</exception>
            <returns>The created report instance.</returns>
        </member>
        <member name="T:SimSharp.SampleMonitor">
            <summary>
            This class calculates some descriptive statistics by
            remembering all data. All observed values are equally weighed.
            
            It can be used to calculate e.g. lead times of processes.
            </summary>
        </member>
        <member name="P:SimSharp.SampleMonitor.Collect">
            <summary>
            Can only be set in the constructor.
            When it is true, median and percentiles can be computed and a
            histogram can be printed. In addition <see cref="P:SimSharp.SampleMonitor.Samples"/>
            may return all the remembered values for further processing.
            </summary>
        </member>
        <member name="P:SimSharp.SampleMonitor.Active">
            <summary>
            The monitor can be set to suppress updates. When it is set
            to false, the statistics will not be updated and new samples
            are ignored.
            </summary>
        </member>
        <member name="P:SimSharp.SampleMonitor.Name">
            <summary>
            The name of the variable that is being monitored.
            Used for output in <see cref="M:SimSharp.SampleMonitor.Summarize(System.Boolean,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double})"/>.
            </summary>
        </member>
        <member name="P:SimSharp.SampleMonitor.Samples">
            <summary>
            Returns the list of collected values, or an empty enumerable
            when <see cref="P:SimSharp.SampleMonitor.Collect"/> was initialized to false.
            </summary>
        </member>
        <member name="M:SimSharp.SampleMonitor.GetMedian">
            <summary>
            Calls <see cref="M:SimSharp.SampleMonitor.GetPercentile(System.Double)"/>.
            </summary>
            <remarks>
            Median can only be computed when the monitor was initialized to collect the data.
            
            The data is preprocessed on every call, the runtime complexity of this method is therefore O(n * log(n)).
            </remarks>
            <returns>The median (50th percentile) of the samples.</returns>
        </member>
        <member name="M:SimSharp.SampleMonitor.GetPercentile(System.Double)">
            <summary>
            Calculates the p-percentile of the samples.
            </summary>
            <remarks>
            Percentiles can only be computed when the monitor was initialized to collect the data.
            
            The data is preprocessed on every call, the runtime complexity of this method is therefore O(n * log(n)).
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="p"/> is outside the valid range.</exception>
            <param name="p">The percentile has to be in the range [0;1].</param>
            <returns>The respective percentile of the samples.</returns>
        </member>
        <member name="M:SimSharp.SampleMonitor.Summarize(System.Boolean,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Provides a summary of the statistics in a certain format.
            If the monitor is configured to collect data, it may also print a histogram.
            </summary>
            <param name="withHistogram">Whether to suppress the histogram.
            This is only effective if <see cref="P:SimSharp.SampleMonitor.Collect"/> was set to true, otherwise
            the data to produce the histogram is not available in the first place.</param>
            <param name="maxBins">The maximum number of bins that should be used.
            Note that the bin width and thus the number of bins is also governed by
            <paramref name="binWidth"/> if it is defined.
            This is only effective if <see cref="P:SimSharp.SampleMonitor.Collect"/> and <paramref name="withHistogram"/>
            was set to true, otherwise the data to produce the histogram is not available
            in the first place.</param>
            <param name="histMin">The minimum for the histogram to start at or the sample
            minimum in case the default (null) is given.
            This is only effective if <see cref="P:SimSharp.SampleMonitor.Collect"/> and <paramref name="withHistogram"/>
            was set to true, otherwise the data to produce the histogram is not available
            in the first place.</param>
            <param name="binWidth">The interval for the bins of the histogram or the
            range (<see cref="P:SimSharp.SampleMonitor.Max"/> - <see cref="P:SimSharp.SampleMonitor.Min"/>) divided by the number of bins
            (<paramref name="maxBins"/>) in case the default value (null) is given.
            This is only effective if <see cref="P:SimSharp.SampleMonitor.Collect"/> and <paramref name="withHistogram"/>
            was set to true, otherwise the data to produce the histogram is not available
            in the first place.</param>
            <returns>A formatted string that provides a summary of the statistics.</returns>
        </member>
        <member name="T:SimSharp.TimeSeriesMonitor">
            <summary>
            This class calculates weighted statistics of a time series variable.
            The weight is given as the duration of the variable's value.
            
            It is typically used to calculate utilization of resources or inventory levels.
            </summary>
            <remarks>
            The monitor updates the statistics online, except for <see cref="M:SimSharp.TimeSeriesMonitor.GetMedian"/>
            which is calculated given the collected data whenever it is called.
            When the monitor was initialized with collect = false in the constructor,
            median and other percentiles cannot be computed (double.NaN is returned).
            Also to print a histogram requires that the monitor was initialized to collect
            all the changes to the variable's value.
            
            Collecting the data naturally incurs some memory overhead.
            </remarks>
        </member>
        <member name="P:SimSharp.TimeSeriesMonitor.Collect">
            <summary>
            Can only be set in the constructor.
            When it is true, median and percentiles can be computed and a
            histogram can be printed. In addition <see cref="P:SimSharp.TimeSeriesMonitor.Series"/>
            may return all the remembered values for further processing.
            </summary>
        </member>
        <member name="P:SimSharp.TimeSeriesMonitor.Active">
            <summary>
            The monitor can be set to suppress updates. When it is set
            to false, the statistics, except for <see cref="P:SimSharp.TimeSeriesMonitor.Current"/>
            will not be updated and new samples are ignored.
            When set to true it will resume updates from the current
            simulation time onward.
            </summary>
        </member>
        <member name="P:SimSharp.TimeSeriesMonitor.Name">
            <summary>
            The name of the variable that is being monitored.
            Used for output in <see cref="M:SimSharp.TimeSeriesMonitor.Summarize(System.Boolean,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double})"/>.
            </summary>
        </member>
        <member name="P:SimSharp.TimeSeriesMonitor.Series">
            <summary>
            Returns the list of collected values, or an empty enumerable
            when <see cref="P:SimSharp.TimeSeriesMonitor.Collect"/> was initialized to false.
            </summary>
        </member>
        <member name="M:SimSharp.TimeSeriesMonitor.GetMedian">
            <summary>
            Calls <see cref="M:SimSharp.TimeSeriesMonitor.GetPercentile(System.Double)"/>.
            </summary>
            <remarks>
            Median can only be computed when the monitor was initialized to collect the data.
            
            The data is preprocessed on every call, the runtime complexity of this method is therefore O(n * log(n)).
            </remarks>
            <returns>The median (50th percentile) of the time series.</returns>
        </member>
        <member name="M:SimSharp.TimeSeriesMonitor.GetPercentile(System.Double)">
            <summary>
            Calculates the weighted p-percentile of the sampled levels (duration is the weight).
            </summary>
            <remarks>
            Percentiles can only be computed when the monitor was initialized to collect the data.
            
            The data is preprocessed on every call, the runtime complexity of this method is therefore O(n * log(n)).
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="p"/> is outside the valid range.</exception>
            <param name="p">The percentile has to be in the range [0;1].</param>
            <returns>The respective percentile of the time series.</returns>
        </member>
        <member name="M:SimSharp.TimeSeriesMonitor.Summarize(System.Boolean,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Provides a summary of the statistics in a certain format.
            If the monitor is configured to collect data, it may also print a histogram.
            </summary>
            <param name="withHistogram">Whether to suppress the histogram.
            This is only effective if <see cref="P:SimSharp.TimeSeriesMonitor.Collect"/> was set to true, otherwise
            the data to produce the histogram is not available in the first place.</param>
            <param name="maxBins">The maximum number of bins that should be used.
            Note that the bin width and thus the number of bins is also governed by
            <paramref name="binWidth"/> if it is defined.
            This is only effective if <see cref="P:SimSharp.TimeSeriesMonitor.Collect"/> and <paramref name="withHistogram"/>
            was set to true, otherwise the data to produce the histogram is not available
            in the first place.</param>
            <param name="histMin">The minimum for the histogram to start at or the sample
            minimum in case the default (null) is given.
            This is only effective if <see cref="P:SimSharp.TimeSeriesMonitor.Collect"/> and <paramref name="withHistogram"/>
            was set to true, otherwise the data to produce the histogram is not available
            in the first place.</param>
            <param name="binWidth">The interval for the bins of the histogram or the
            range (<see cref="P:SimSharp.TimeSeriesMonitor.Max"/> - <see cref="P:SimSharp.TimeSeriesMonitor.Min"/>) divided by the number of bins
            (<paramref name="maxBins"/>) in case the default value (null) is given.
            This is only effective if <see cref="P:SimSharp.TimeSeriesMonitor.Collect"/> and <paramref name="withHistogram"/>
            was set to true, otherwise the data to produce the histogram is not available
            in the first place.</param>
            <returns>A formatted string that provides a summary of the statistics.</returns>
        </member>
        <member name="T:SimSharp.EventQueue">
            <summary>
            An implementation of a min-Priority Queue using a heap.  Has O(1) .Contains()!
            See https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started for more information
            </summary>
            <remarks>
            There are modifications so that the type is not generic anymore and can only hold values of type EventQueueNode
            </remarks>
        </member>
        <member name="M:SimSharp.EventQueue.#ctor(System.Int32)">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">EventQueueNodehe max nodes ever allowed to be enqueued (going over this will cause an exception)</param>
        </member>
        <member name="P:SimSharp.EventQueue.Count">
            <summary>
            Returns the number of nodes in the queue.  O(1)
            </summary>
        </member>
        <member name="P:SimSharp.EventQueue.MaxSize">
            <summary>
            Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
            attempting to enqueue another item will throw an exception.  O(1)
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.Clear">
            <summary>
            Removes every node from the queue.  O(n) (So, don't do this often!)
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.Contains(SimSharp.EventQueueNode)">
            <summary>
            Returns (in O(1)!) whether the given node is in the queue.  O(1)
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.Enqueue(System.DateTime,SimSharp.Event,System.Int32)">
            <summary>
            Enqueue a node - .Priority must be set beforehand!  O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.HasHigherPriority(SimSharp.EventQueueNode,SimSharp.EventQueueNode)">
            <summary>
            Returns true if 'higher' has higher priority than 'lower', false otherwise.
            Note that calling HasHigherPriority(node, node) (ie. both arguments the same node) will return false
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.Dequeue">
            <summary>
            Removes the head of the queue (node with highest priority; ties are broken by order of insertion), and returns it.  O(log n)
            </summary>
        </member>
        <member name="P:SimSharp.EventQueue.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).  O(1)
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.UpdatePriority(SimSharp.EventQueueNode,System.DateTime,System.Int32)">
            <summary>
            This method must be called on a node every time its priority changes while it is in the queue.  
            <b>Forgetting to call this method will result in a corrupted queue!</b>
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.Remove(SimSharp.EventQueueNode)">
            <summary>
            Removes a node from the queue.  Note that the node does not need to be the head of the queue.  O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.EventQueue.IsValidQueue">
            <summary>
            <b>Should not be called in production code.</b>
            Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
            </summary>
        </member>
        <member name="P:SimSharp.EventQueueNode.PrimaryPriority">
            <summary>
            The Priority to insert this node at. Must be set BEFORE adding a node to the queue.
            </summary>
        </member>
        <member name="P:SimSharp.EventQueueNode.SecondaryPriority">
            <summary>
            An integer priority that will be used to distinguish nodes with the same
            <see cref="P:SimSharp.EventQueueNode.PrimaryPriority"/> and before the <see cref="P:SimSharp.EventQueueNode.InsertionIndex"/> is used.
            Must be set BEFORE adding a node to the queue.
            </summary>
            <remarks>
            A lower value means higher priority, thus int.MinValue has highest priority.
            </remarks>
        </member>
        <member name="P:SimSharp.EventQueueNode.Event">
            <summary>
            The event that is associated with this node.
            </summary>
        </member>
        <member name="P:SimSharp.EventQueueNode.InsertionIndex">
            <summary>
            <b>Used by the priority queue - do not edit this value.</b>
            Represents the order the node was inserted in
            </summary>
            <remarks>
            This is unique among all inserted nodes and thus represents the third and final priority.
            </remarks>
        </member>
        <member name="P:SimSharp.EventQueueNode.QueueIndex">
            <summary>
            <b>Used by the priority queue - do not edit this value.</b>
            Represents the current position in the queue
            </summary>
        </member>
        <member name="T:SimSharp.GenericPriorityQueue`2">
            <summary>
            A copy of StablePriorityQueue which also has generic explicit priority-type
            </summary>
            <remarks>
            Original sources from https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp
            </remarks>
            <typeparam name="TItem">The values in the queue.  Must extend the GenericPriorityQueue class</typeparam>
            <typeparam name="TPriority">The priority-type.  Must extend IComparable&lt;TPriority&gt;</typeparam>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.#ctor(System.Int32)">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`1})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
            <param name="comparer">The comparer used to compare TPriority values.</param>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.#ctor(System.Int32,System.Comparison{`1})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
            <param name="comparer">The comparison function to use to compare TPriority values</param>
        </member>
        <member name="P:SimSharp.GenericPriorityQueue`2.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:SimSharp.GenericPriorityQueue`2.MaxSize">
            <summary>
            Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
            attempting to enqueue another item will cause undefined behavior.  O(1)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.Clear">
            <summary>
            Removes every node from the queue.
            O(n) (So, don't do this often!)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.Contains(`0)">
            <summary>
            Returns (in O(1)!) whether the given node is in the queue.  O(1)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.Enqueue(`0,`1)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
            If the queue is full, the result is undefined.
            If the node is already enqueued, the result is undefined.
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.HasHigherPriority(`0,`0)">
            <summary>
            Returns true if 'higher' has higher priority than 'lower', false otherwise.
            Note that calling HasHigherPriority(node, node) (ie. both arguments the same node) will return false
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.Dequeue">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
            If queue is empty, result is undefined
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.Resize(System.Int32)">
            <summary>
            Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
            Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
            O(n)
            </summary>
        </member>
        <member name="P:SimSharp.GenericPriorityQueue`2.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            If the queue is empty, behavior is undefined.
            O(1)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.UpdatePriority(`0,`1)">
            <summary>
            This method must be called on a node every time its priority changes while it is in the queue.  
            <b>Forgetting to call this method will result in a corrupted queue!</b>
            Calling this method on a node not in the queue results in undefined behavior
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.Remove(`0)">
            <summary>
            Removes a node from the queue.  The node does not need to be the head of the queue.  
            If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`2.IsValidQueue">
            <summary>
            <b>Should not be called in production code.</b>
            Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
            </summary>
        </member>
        <member name="T:SimSharp.GenericPriorityQueue`1">
            <summary>
            A copy of StablePriorityQueue where the items themselves contain an implicit priority.
            </summary>
            <remarks>
            Either <typeparamref name="TItem"/> implements IComparable&lt;typeparamref name="TItem"/>&gt; or
            a custom comparer must be provided.
            </remarks>
            <typeparam name="TItem">The values in the queue. Must extend the GenericPriorityQueueNode class</typeparam>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
            <param name="comparer">The comparer used to compare TPriority values.</param>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.#ctor(System.Int32,System.Comparison{`0})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
            <param name="comparer">The comparison function to use to compare TPriority values</param>
        </member>
        <member name="P:SimSharp.GenericPriorityQueue`1.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:SimSharp.GenericPriorityQueue`1.MaxSize">
            <summary>
            Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
            attempting to enqueue another item will cause undefined behavior.  O(1)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.Clear">
            <summary>
            Removes every node from the queue.
            O(n) (So, don't do this often!)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.Contains(`0)">
            <summary>
            Returns (in O(1)!) whether the given node is in the queue.  O(1)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
            If the queue is full, the result is undefined.
            If the node is already enqueued, the result is undefined.
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.HasHigherPriority(`0,`0)">
            <summary>
            Returns true if 'higher' has higher priority than 'lower', false otherwise.
            Note that calling HasHigherPriority(node, node) (ie. both arguments the same node) will return false
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.Dequeue">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
            If queue is empty, result is undefined
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.Resize(System.Int32)">
            <summary>
            Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
            Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
            O(n)
            </summary>
        </member>
        <member name="P:SimSharp.GenericPriorityQueue`1.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            If the queue is empty, behavior is undefined.
            O(1)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.UpdatePriority(`0)">
            <summary>
            This method must be called on a node every time its priority changes while it is in the queue.  
            <b>Forgetting to call this method will result in a corrupted queue!</b>
            Calling this method on a node not in the queue results in undefined behavior
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.Remove(`0)">
            <summary>
            Removes a node from the queue.  The node does not need to be the head of the queue.  
            If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.GenericPriorityQueue`1.IsValidQueue">
            <summary>
            <b>Should not be called in production code.</b>
            Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
            </summary>
        </member>
        <member name="T:SimSharp.GenericPriorityQueueNode">
            <summary>
            A node class for the generic priority queue
            </summary>
        </member>
        <member name="P:SimSharp.GenericPriorityQueueNode.QueueIndex">
            <summary>
            Represents the current position in the queue
            </summary>
        </member>
        <member name="P:SimSharp.GenericPriorityQueueNode.InsertionIndex">
            <summary>
            Represents the order the node was inserted in
            </summary>
        </member>
        <member name="T:SimSharp.GenericPriorityQueueNode`1">
            <summary>
            A node class for the generic priority queue with an explicit priority type
            </summary>
            <remarks>
            Original sources from https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp
            </remarks>
            <typeparam name="TPriority"></typeparam>
        </member>
        <member name="P:SimSharp.GenericPriorityQueueNode`1.Priority">
            <summary>
            The Priority to insert this node at.  Must be set BEFORE adding a node to the queue (ideally just once, in the node's constructor).
            Should not be manually edited once the node has been enqueued - use queue.UpdatePriority() instead
            </summary>
        </member>
        <member name="T:SimSharp.SimplePriorityQueue`2">
            <summary>
            A simplified priority queue implementation.  Is stable, auto-resizes, and thread-safe, at the cost of being slightly slower than
            FastPriorityQueue
            Methods tagged as O(1) or O(log n) are assuming there are no duplicates.  Duplicates may increase the algorithmic complexity.
            </summary>
            <remarks>
            Original sources from https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp
            </remarks>
            <typeparam name="TItem">The type to enqueue</typeparam>
            <typeparam name="TPriority">The priority-type to use for nodes.  Must extend IComparable&lt;TPriority&gt;</typeparam>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.#ctor">
            <summary>
            Instantiate a new Priority Queue
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`1})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="comparer">The comparer used to compare TPriority values.  Defaults to Comparer&lt;TPriority&gt;.default</param>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.#ctor(System.Comparison{`1})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="comparer">The comparison function to use to compare TPriority values</param>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.GetExistingNode(`0)">
            <summary>
            Given an item of type T, returns the exist SimpleNode in the queue
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.AddToNodeCache(SimSharp.SimplePriorityQueue{`0,`1}.SimpleNode)">
            <summary>
            Adds an item to the Node-cache to allow for many methods to be O(1) or O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.RemoveFromNodeCache(SimSharp.SimplePriorityQueue{`0,`1}.SimpleNode)">
            <summary>
            Removes an item to the Node-cache to allow for many methods to be O(1) or O(log n) (assuming no duplicates)
            </summary>
        </member>
        <member name="P:SimSharp.SimplePriorityQueue`2.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:SimSharp.SimplePriorityQueue`2.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            Throws an exception when the queue is empty.
            O(1)
            </summary>
        </member>
        <member name="P:SimSharp.SimplePriorityQueue`2.Peek">
            <summary>
            Returns the top priority of the queue.
            Throws an exception when the queue is empty.
            O(1)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.Clear">
            <summary>
            Removes every node from the queue.
            O(n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.Contains(`0)">
            <summary>
            Returns whether the given item is in the queue.
            O(1)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.Dequeue">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
            If queue is empty, throws an exception
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.EnqueueNoCache(`0,`1)">
            <summary>
            Enqueue the item with the given priority, without calling AddToNodeCache(node)
            </summary>
            <param name="item"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.Enqueue(`0,`1)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
            This queue automatically resizes itself, so there's no concern of the queue becoming 'full'.
            Duplicates and null-values are allowed.
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.EnqueueWithoutDuplicates(`0,`1)">
            <summary>
            Enqueue a node to the priority queue if it doesn't already exist.  Lower values are placed in front. Ties are broken by first-in-first-out.
            This queue automatically resizes itself, so there's no concern of the queue becoming 'full'.  Null values are allowed.
            Returns true if the node was successfully enqueued; false if it already exists.
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.Remove(`0)">
            <summary>
            Removes an item from the queue.  The item does not need to be the head of the queue.  
            If the item is not in the queue, an exception is thrown.  If unsure, check Contains() first.
            If multiple copies of the item are enqueued, only the first one is removed. 
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.UpdatePriority(`0,`1)">
            <summary>
            Call this method to change the priority of an item.
            Calling this method on a item not in the queue will throw an exception.
            If the item is enqueued multiple times, only the first one will be updated.
            (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
            to update all of them, please wrap your items in a wrapper class so they can be distinguished).
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.GetPriority(`0)">
            <summary>
            Returns the priority of the given item.
            Calling this method on a item not in the queue will throw an exception.
            If the item is enqueued multiple times, only the priority of the first will be returned.
            (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
            to query all their priorities, please wrap your items in a wrapper class so they can be distinguished).
            O(1)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.TryFirst(`0@)">
            Get the head of the queue, without removing it (use TryDequeue() for that).
            Useful for multi-threading, where the queue may become empty between calls to Contains() and First
            Returns true if successful, false otherwise
            O(1)
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.TryDequeue(`0@)">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and sets it to first.
            Useful for multi-threading, where the queue may become empty between calls to Contains() and Dequeue()
            Returns true if successful; false if queue was empty
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.TryRemove(`0)">
            <summary>
            Attempts to remove an item from the queue.  The item does not need to be the head of the queue.  
            Useful for multi-threading, where the queue may become empty between calls to Contains() and Remove()
            Returns true if the item was successfully removed, false if it wasn't in the queue.
            If multiple copies of the item are enqueued, only the first one is removed. 
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.TryUpdatePriority(`0,`1)">
            <summary>
            Call this method to change the priority of an item.
            Useful for multi-threading, where the queue may become empty between calls to Contains() and UpdatePriority()
            If the item is enqueued multiple times, only the first one will be updated.
            (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
            to update all of them, please wrap your items in a wrapper class so they can be distinguished).
            Returns true if the item priority was updated, false otherwise.
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`2.TryGetPriority(`0,`1@)">
            <summary>
            Attempt to get the priority of the given item.
            Useful for multi-threading, where the queue may become empty between calls to Contains() and GetPriority()
            If the item is enqueued multiple times, only the priority of the first will be returned.
            (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
            to query all their priorities, please wrap your items in a wrapper class so they can be distinguished).
            Returns true if the item was found in the queue, false otherwise
            O(1)
            </summary>
        </member>
        <member name="T:SimSharp.SimplePriorityQueue`1">
            <summary>
            A simplified priority queue implementation.  Is stable, auto-resizes, and thread-safe, at the cost of being slightly slower than
            FastPriorityQueue
            Methods tagged as O(1) or O(log n) are assuming there are no duplicates.  Duplicates may increase the algorithmic complexity.
            </summary>
            <typeparam name="TItem">The type to enqueue</typeparam>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.#ctor">
            <summary>
            Instantiate a new Priority Queue
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="comparer">The comparer used to compare TPriority values.  Defaults to Comparer&lt;TPriority&gt;.default</param>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.#ctor(System.Comparison{`0})">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="comparer">The comparison function to use to compare TPriority values</param>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.GetExistingNode(`0)">
            <summary>
            Given an item of type T, returns the exist SimpleNode in the queue
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.AddToNodeCache(SimSharp.SimplePriorityQueue{`0}.SimpleNode)">
            <summary>
            Adds an item to the Node-cache to allow for many methods to be O(1) or O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.RemoveFromNodeCache(SimSharp.SimplePriorityQueue{`0}.SimpleNode)">
            <summary>
            Removes an item to the Node-cache to allow for many methods to be O(1) or O(log n) (assuming no duplicates)
            </summary>
        </member>
        <member name="P:SimSharp.SimplePriorityQueue`1.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:SimSharp.SimplePriorityQueue`1.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            Throws an exception when the queue is empty.
            O(1)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.Clear">
            <summary>
            Removes every node from the queue.
            O(n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.Contains(`0)">
            <summary>
            Returns whether the given item is in the queue.
            O(1)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.Dequeue">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
            If queue is empty, throws an exception
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.EnqueueNoCache(`0)">
            <summary>
            Enqueue the item with the given priority, without calling AddToNodeCache(node)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
            This queue automatically resizes itself, so there's no concern of the queue becoming 'full'.
            Duplicates and null-values are allowed.
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.EnqueueWithoutDuplicates(`0)">
            <summary>
            Enqueue a node to the priority queue if it doesn't already exist.  Lower values are placed in front. Ties are broken by first-in-first-out.
            This queue automatically resizes itself, so there's no concern of the queue becoming 'full'.  Null values are allowed.
            Returns true if the node was successfully enqueued; false if it already exists.
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.Remove(`0)">
            <summary>
            Removes an item from the queue.  The item does not need to be the head of the queue.  
            If the item is not in the queue, an exception is thrown.  If unsure, check Contains() first.
            If multiple copies of the item are enqueued, only the first one is removed. 
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.UpdatePriority(`0)">
            <summary>
            Call this method to change the priority of an item.
            Calling this method on a item not in the queue will throw an exception.
            If the item is enqueued multiple times, only the first one will be updated.
            (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
            to update all of them, please wrap your items in a wrapper class so they can be distinguished).
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.TryFirst(`0@)">
            Get the head of the queue, without removing it (use TryDequeue() for that).
            Useful for multi-threading, where the queue may become empty between calls to Contains() and First
            Returns true if successful, false otherwise
            O(1)
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.TryDequeue(`0@)">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and sets it to first.
            Useful for multi-threading, where the queue may become empty between calls to Contains() and Dequeue()
            Returns true if successful; false if queue was empty
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.TryRemove(`0)">
            <summary>
            Attempts to remove an item from the queue.  The item does not need to be the head of the queue.  
            Useful for multi-threading, where the queue may become empty between calls to Contains() and Remove()
            Returns true if the item was successfully removed, false if it wasn't in the queue.
            If multiple copies of the item are enqueued, only the first one is removed. 
            O(log n)
            </summary>
        </member>
        <member name="M:SimSharp.SimplePriorityQueue`1.TryUpdatePriority(`0)">
            <summary>
            Call this method to change the priority of an item.
            Useful for multi-threading, where the queue may become empty between calls to Contains() and UpdatePriority()
            If the item is enqueued multiple times, only the first one will be updated.
            (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
            to update all of them, please wrap your items in a wrapper class so they can be distinguished).
            Returns true if the item priority was updated, false otherwise.
            O(log n)
            </summary>
        </member>
        <member name="T:SimSharp.Simulation">
            <summary>
            Simulation hold the event queues, schedule and process events.
            </summary>
            <remarks>
            This class is not thread-safe against manipulation of the event queue. If you supply a termination
            event that is set outside the simulation thread, please use the <see cref="T:SimSharp.ThreadSafeSimulation"/> environment.
            
            For most purposes <see cref="T:SimSharp.Simulation"/> is however the better and faster choice.
            </remarks>
        </member>
        <member name="P:SimSharp.Simulation.DefaultTimeStepSeconds">
            <summary>
            Describes the number of seconds that a logical step of 1 in the *D-API takes.
            </summary>
        </member>
        <member name="P:SimSharp.Simulation.NowD">
            <summary>
            Calculates the logical date of the simulation by the amount of default steps
            that have passed.
            </summary>
        </member>
        <member name="P:SimSharp.Simulation.Now">
            <summary>
            The current simulation time as a calendar date.
            </summary>
        </member>
        <member name="P:SimSharp.Simulation.StartDate">
            <summary>
            The calendar date when the simulation started. This defaults to 1970-1-1 if
            no other date has been specified in the overloaded constructor.
            </summary>
        </member>
        <member name="P:SimSharp.Simulation.Random">
            <summary>
            The random number generator that is to be used in all events in
            order to produce reproducible results.
            </summary>
        </member>
        <member name="M:SimSharp.Simulation.Process(System.Collections.Generic.IEnumerable{SimSharp.Event},System.Int32)">
            <summary>
            Creates a new process from an event generator. The process is automatically
            scheduled to be started at the current simulation time.
            </summary>
            <param name="generator">The generator function that represents the process.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
            <returns>The scheduled process that was created.</returns>
        </member>
        <member name="M:SimSharp.Simulation.TimeoutD(System.Double,System.Int32)">
            <summary>
            Creates and returns a new timeout.
            </summary>
            <param name="delay">The time after which the timeout is fired.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
            <returns>The scheduled timeout event that was created.</returns>
        </member>
        <member name="M:SimSharp.Simulation.Timeout(System.TimeSpan,System.Int32)">
            <summary>
            Creates and returns a new timeout.
            </summary>
            <param name="delay">The time after which the timeout is fired.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
            <returns>The scheduled timeout event that was created.</returns>
        </member>
        <member name="M:SimSharp.Simulation.Schedule(SimSharp.Event,System.Int32)">
            <summary>
            Schedules an event to occur at the same simulation time as the call was made.
            </summary>
            <param name="event">The event that should be scheduled.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.Simulation.Schedule(System.TimeSpan,SimSharp.Event,System.Int32)">
            <summary>
            Schedules an event to occur after a certain (positive) delay.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="delay"/> is negative.
            </exception>
            <param name="delay">The (positive) delay after which the event should be fired.</param>
            <param name="event">The event that should be scheduled.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.Simulation.Run(SimSharp.Event)">
            <summary>
            Run until a certain event is processed.
            </summary>
            <remarks>
            This simulation environment is not thread-safe, thus triggering this event outside the environment
            leads to potential race conditions. Please use the <see cref="T:SimSharp.ThreadSafeSimulation"/> environment in case you
            require this functionality. Note that the performance of <see cref="T:SimSharp.ThreadSafeSimulation"/> is lower due to locking.
            
            For real-time based termination, you can also call <see cref="M:SimSharp.Simulation.StopAsync"/> which sets a flag indicating the simulation
            to stop before processing the next event.
            </remarks>
            <param name="stopEvent">The event that stops the simulation.</param>
            <returns></returns>
        </member>
        <member name="M:SimSharp.Simulation.Step">
            <summary>
            Performs a single step of the simulation, i.e. process a single event
            </summary>
            <remarks>
            This method is not thread-safe
            </remarks>
        </member>
        <member name="M:SimSharp.Simulation.PeekD">
            <summary>
            Peeks at the time of the next event in terms of the defined step
            </summary>
            <remarks>
            This method is not thread-safe
            </remarks>
        </member>
        <member name="M:SimSharp.Simulation.Peek">
            <summary>
            Peeks at the time of the next event
            </summary>
            <remarks>
            This method is not thread-safe
            </remarks>
        </member>
        <member name="M:SimSharp.Simulation.RandExponential(SimSharp.IRandom,System.Double)">
            <summary>
            Returns a number that is exponentially distributed given a certain mean.
            </summary>
            <remarks>
            Unlike in other APIs here the mean should be given and not the lambda parameter.
            </remarks>
            <param name="random">The random number generator to use.</param>
            <param name="mean">The mean(!) of the distribution is 1 / lambda.</param>
            <returns>A number that is exponentially distributed</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandExponential(System.Double)">
            <summary>
            Returns a number that is exponentially distributed given a certain mean.
            </summary>
            <remarks>
            Unlike in other APIs here the mean should be given and not the lambda parameter.
            </remarks>
            <param name="mean">The mean(!) of the distribution is 1 / lambda.</param>
            <returns>A number that is exponentially distributed</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandExponential(SimSharp.IRandom,System.TimeSpan)">
            <summary>
            Returns a timespan that is exponentially distributed given a certain mean.
            </summary>
            <remarks>
            Unlike in other APIs here the mean should be given and not the lambda parameter.
            </remarks>
            <param name="random">The random number generator to use.</param>
            <param name="mean">The mean(!) of the distribution is 1 / lambda.</param>
            <returns>A number that is exponentially distributed</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandExponential(System.TimeSpan)">
            <summary>
            Returns a timespan that is exponentially distributed given a certain mean.
            </summary>
            <remarks>
            Unlike in other APIs here the mean should be given and not the lambda parameter.
            </remarks>
            <param name="mean">The mean(!) of the distribution is 1 / lambda.</param>
            <returns>A number that is exponentially distributed</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandNormal(SimSharp.IRandom,System.Double,System.Double)">
            <summary>
            Uses the Marsaglia polar method to generate a random variable
            from two uniform random distributed values.
            </summary>
            <remarks>
            Unlike <see cref="M:SimSharp.Simulation.RandNormal(System.Double,System.Double)"/> this method does not
            make use of a spare random variable. It discards the spare and thus
            requires twice the number of calls to the underlying IRandom instance.
            </remarks>
            <param name="random">The random number generator to use.</param>
            <param name="mu">The mean of the normal distribution.</param>
            <param name="sigma">The standard deviation of the normal distribution.</param>
            <returns>A number that is normal distributed.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandNormal(System.Double,System.Double)">
            <summary>
            Uses the Marsaglia polar method to generate a random variable
            from two uniform random distributed values.
            </summary>
            <remarks>
            A spare random variable is generated from the second uniformly
            distributed value. Thus, the two calls to the uniform random number
            generator will be made only every second call.
            </remarks>
            <param name="mu">The mean of the normal distribution.</param>
            <param name="sigma">The standard deviation of the normal distribution.</param>
            <returns>A number that is normal distributed.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandNormal(SimSharp.IRandom,System.TimeSpan,System.TimeSpan)">
            <summary>
            Uses the Marsaglia polar method to generate a random variable
            from two uniform random distributed values.
            </summary>
            <remarks>
            A spare random variable is generated from the second uniformly
            distributed value. Thus, the two calls to the uniform random number
            generator will be made only every second call.
            </remarks>
            <param name="random">The random number generator to use.</param>
            <param name="mu">The mean of the normal distribution.</param>
            <param name="sigma">The standard deviation of the normal distribution.</param>
            <returns>A number that is normal distributed.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandNormal(System.TimeSpan,System.TimeSpan)">
            <summary>
            Uses the Marsaglia polar method to generate a random variable
            from two uniform random distributed values.
            </summary>
            <remarks>
            A spare random variable is generated from the second uniformly
            distributed value. Thus, the two calls to the uniform random number
            generator will be made only every second call.
            </remarks>
            <param name="mu">The mean of the normal distribution.</param>
            <param name="sigma">The standard deviation of the normal distribution.</param>
            <returns>A number that is normal distributed.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal(SimSharp.IRandom,System.Double,System.Double)">
            <summary>
            Returns values from a log-normal distribution with the mean
            exp(mu + sigma^2 / 2)
            and the standard deviation
            sqrt([exp(sigma^2)-1] * exp(2 * mu + sigma^2))
            </summary>
            <param name="random">The random number generator to use.</param>
            <param name="mu">The mu parameter of the log-normal distribution (not the mean).</param>
            <param name="sigma">The sigma parameter of the log-normal distribution (not the standard deviation).</param>
            <returns>A log-normal distributed random value.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal(System.Double,System.Double)">
            <summary>
            Returns values from a log-normal distribution with the mean
            exp(mu + sigma^2 / 2)
            and the standard deviation
            sqrt([exp(sigma^2)-1] * exp(2 * mu + sigma^2))
            </summary>
            <param name="mu">The mu parameter of the log-normal distribution (not the mean).</param>
            <param name="sigma">The sigma parameter of the log-normal distribution (not the standard deviation).</param>
            <returns>A log-normal distributed random value.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal2(SimSharp.IRandom,System.Double,System.Double)">
            <summary>
            Returns values from a log-normal distribution with
            the mean <paramref name="mean"/> and standard deviation <paramref name="stdev"/>.
            </summary>
            <param name="random">The random number generator to use.</param>
            <param name="mean">The distribution mean.</param>
            <param name="stdev">The distribution standard deviation.</param>
            <returns>A log-normal distributed random value.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal2(System.Double,System.Double)">
            <summary>
            Returns values from a log-normal distribution with
            the mean <paramref name="mean"/> and standard deviation <paramref name="stdev"/>.
            </summary>
            <param name="mean">The distribution mean.</param>
            <param name="stdev">The distribution standard deviation.</param>
            <returns>A log-normal distributed random value.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal(SimSharp.IRandom,System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a timespan value from a log-normal distribution with the mean
            exp(mu + sigma^2 / 2)
            and the standard deviation
            sqrt([exp(sigma^2)-1] * exp(2 * mu + sigma^2))
            </summary>
            <param name="random">The random number generator to use.</param>
            <param name="mu">The mu parameter of the log-normal distribution (not the mean).</param>
            <param name="sigma">The sigma parameter of the log-normal distribution (not the standard deviation).</param>
            <returns>A log-normal distributed random timespan.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a timespan value from a log-normal distribution with the mean
            exp(mu + sigma^2 / 2)
            and the standard deviation
            sqrt([exp(sigma^2)-1] * exp(2 * mu + sigma^2))
            </summary>
            <param name="mu">The mu parameter of the log-normal distribution (not the mean).</param>
            <param name="sigma">The sigma parameter of the log-normal distribution (not the standard deviation).</param>
            <returns>A log-normal distributed random timespan.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal2(SimSharp.IRandom,System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a timespan value from a log-normal distribution with
            the mean <paramref name="mean"/> and standard deviation <paramref name="stdev"/>.
            </summary>
            <param name="random">The random number generator to use.</param>
            <param name="mean">The distribution mean.</param>
            <param name="stdev">The distribution standard deviation.</param>
            <returns>A log-normal distributed random timespan.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandLogNormal2(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a timespan value from a log-normal distribution with
            the mean <paramref name="mean"/> and standard deviation <paramref name="stdev"/>.
            </summary>
            <param name="mean">The distribution mean.</param>
            <param name="stdev">The distribution standard deviation.</param>
            <returns>A log-normal distributed random timespan.</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandChoice``1(SimSharp.IRandom,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Double})">
            <summary>
            Generates a random sample from a given source
            </summary>
            <typeparam name="T">The type of the element in parameter source</typeparam>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="source"/> and <paramref name="weights"/> have different size.
            or when <paramref name="weights"/> contains an invalid or negative value.
            or when <paramref name="weights"/> sum equals zero or an invalid value.
            </exception>
            <param name="random">The random number generator to use.</param>
            <param name="source">a random sample is generated from its elements.</param>
            <param name="weights">The weight associated with each entry in source.</param>
            <returns>The generated random samples</returns>
        </member>
        <member name="M:SimSharp.Simulation.RandChoice``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Double})">
            <summary>
            Generates a random sample from a given source
            </summary>
            <typeparam name="T">The type of the element in parameter source</typeparam>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="source"/> and <paramref name="weights"/> have different size.
            or when <paramref name="weights"/> contains an invalid or negative value.
            or when <paramref name="weights"/> sum equals zero
            </exception>
            <param name="source">a random sample is generated from its elements.</param>
            <param name="weights">The weight associated with each entry in source.</param>
            <returns>The generated random samples</returns>
        </member>
        <member name="T:SimSharp.ThreadSafeSimulation">
            <summary>
            Provides a simulation environment that is thread-safe against manipulations of the event queue.
            Its performance is somewhat lower than the non-thread-safe environment (cf. <see cref="T:SimSharp.Simulation"/>)
            due to the locking involved.
            </summary>
            <remarks>
            Please carefully consider if you must really schedule the stop event in a separate thread. You can also
            call <see cref="M:SimSharp.Simulation.StopAsync"/> to request termination after the current event has been processed.
            
            The simulation will still run in only one thread and execute all events sequentially.
            </remarks>
        </member>
        <member name="M:SimSharp.ThreadSafeSimulation.Schedule(SimSharp.Event,System.Int32)">
            <summary>
            Schedules an event to occur at the same simulation time as the call was made.
            </summary>
            <remarks>
            This method is thread-safe against manipulations of the event queue
            </remarks>
            <param name="event">The event that should be scheduled.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.ThreadSafeSimulation.Schedule(System.TimeSpan,SimSharp.Event,System.Int32)">
            <summary>
            Schedules an event to occur after a certain (positive) delay.
            </summary>
            <remarks>
            This method is thread-safe against manipulations of the event queue
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="delay"/> is negative.
            </exception>
            <param name="delay">The (positive) delay after which the event should be fired.</param>
            <param name="event">The event that should be scheduled.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.ThreadSafeSimulation.Run(SimSharp.Event)">
            <summary>
            Run until a certain event is processed.
            </summary>
            <remarks>
            This method is thread-safe against manipulations of the event queue
            </remarks>
            <param name="stopEvent">The event that stops the simulation.</param>
            <returns></returns>
        </member>
        <member name="M:SimSharp.ThreadSafeSimulation.RunAsync(SimSharp.Event)">
            <summary>
            Run until a certain event is processed, but does not block.
            </summary>
            <param name="stopEvent">The event that stops the simulation.</param>
            <returns></returns>
        </member>
        <member name="M:SimSharp.ThreadSafeSimulation.Step">
            <summary>
            Performs a single step of the simulation, i.e. process a single event
            </summary>
            <remarks>
            This method is thread-safe against manipulations of the event queue
            </remarks>
        </member>
        <member name="M:SimSharp.ThreadSafeSimulation.PeekD">
            <summary>
            Peeks at the time of the next event in terms of the defined step
            </summary>
            <remarks>
            This method is thread-safe against manipulations of the event queue
            </remarks>
        </member>
        <member name="M:SimSharp.ThreadSafeSimulation.Peek">
            <summary>
            Peeks at the time of the next event
            </summary>
            <remarks>
            This method is thread-safe against manipulations of the event queue
            </remarks>
        </member>
        <member name="T:SimSharp.PseudoRealtimeSimulation">
            <summary>
            Provides a simulation environment where delays in simulation time may result in a similar
            delay in wall-clock time. The environment is not an actual realtime simulation environment
            in that there is no guarantee that 3 seconds in model time are also exactly 3 seconds in
            observed wall-clock time. This simulation environment is a bit slower, as the overhead of
            the simulation kernel (event creation, queuing, processing, etc.) is not accounted for.
            
            However, it features a switch between virtual and realtime, thus allowing it to be used
            in contexts where realtime is only necessary sometimes (e.g. during interaction with
            long-running co-processes). Such use cases may arise in simulation control problems.
            </summary>
        </member>
        <member name="P:SimSharp.PseudoRealtimeSimulation.RealtimeScale">
            <summary>
            The scale at which the simulation runs in comparison to realtime. A value smaller
            than 1 results in longer-than-realtime delays, while a value larger than 1 results
            in shorter-than-realtime delays. A value of exactly 1 is realtime.
            </summary>
        </member>
        <member name="P:SimSharp.PseudoRealtimeSimulation.IsRunningInRealtime">
            <summary>
            Whether a non-null <see cref="P:SimSharp.PseudoRealtimeSimulation.RealtimeScale"/> has been set.
            </summary>
        </member>
        <member name="P:SimSharp.PseudoRealtimeSimulation.Now">
            <summary>
            The current model time. Note that, while in realtime, this may continuously change.
            </summary>
        </member>
        <member name="M:SimSharp.PseudoRealtimeSimulation.SetVirtualtime">
            <summary>
            Switches the simulation to virtual time mode, i.e., running as fast as possible.
            In this mode, events are processed without delay just like in a <see cref="T:SimSharp.ThreadSafeSimulation"/>.
            </summary>
            <remarks>
            An ongoing real-time delay is being canceled when this method is called. Usually, this
            is only the case when this method is called from a thread other than the main simulation thread.
            
            If the simulation is already in virtual time mode, this method has no effect.
            </remarks>
        </member>
        <member name="M:SimSharp.PseudoRealtimeSimulation.SetRealtime(System.Double)">
            <summary>
            Switches the simulation to real time mode. The real time factor of
            this default mode is configurable.
            </summary>
            <remarks>
            If this method is called while running in real-time mode, but given a different
            <paramref name="realtimeScale"/>, the current delay is canceled and the remaining
            time is delayed using the new time factor.
            
            The default factor is 1, i.e., real time - a timeout of 5 seconds would cause
            a wall-clock delay of 5 seconds. With a factor of 2, the delay as measured by
            a wall clock would be 2.5 seconds, whereas a factor of 0.5, a wall-clock delay of
            10 seconds would be observed.
            </remarks>
            <param name="realtimeScale">A value strictly greater than 0 used to scale real time events.</param>
        </member>
        <member name="M:SimSharp.PseudoRealtimeSimulation.PseudoRealtimeProcess(System.Collections.Generic.IEnumerable{SimSharp.Event},System.Int32,System.Double)">
            <summary>
            This is only a convenience for mixed real- and virtual time simulations.
            It creates a new pseudo realtime process which will set the simulation
            to realtime every time it continues (e.g., if it has been set to virtual time).
            The process is automatically scheduled to be started at the current simulation time.
            </summary>
            <param name="generator">The generator function that represents the process.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
            <param name="realtimeScale">A value strictly greater than 0 used to scale real time events (1 = realtime).</param>
            <returns>The scheduled process that was created.</returns>
        </member>
        <member name="T:SimSharp.Environment">
            <summary>
            Environments hold the event queues, schedule and process events.
            </summary>
        </member>
        <member name="T:SimSharp.Condition">
            <summary>
            Conditions are events that execute when any or all of its sub-events are executed.
            </summary>
        </member>
        <member name="T:SimSharp.Event">
            <summary>
            The base class for all events in SimSharp.
            An event can be in one of three states at any time:
             - Alive: The event object exists, but is neither scheduled to
                      be executed, nor is it already executed.
             - Triggered: The event has been put in the event queue and is
                          going to be executed.
             - Processed: The event has been executed.
            
            Usually, the event is alive until its Trigger, Succeed, or Fail
            method have been called. Then it becomes triggered. When the
            Environment progresses to the event and executes its callbacks
            the event becomes processed.
            </summary>
        </member>
        <member name="P:SimSharp.Event.Value">
            <summary>
            The value property can be used to return arbitrary data from a
            process or an event. It also represents the interrupt cause to
            a process.
            </summary>
        </member>
        <member name="P:SimSharp.Event.IsOk">
            <summary>
            The IsOk flag indicates if the event succeeded or failed. An event
            that failed indicates to a waiting process that the action could
            not be performed and that the faulting situation must be handled.
            Typically, interrupting a process sets the IsOk flag to false.
            </summary>
        </member>
        <member name="P:SimSharp.Event.IsAlive">
            <summary>
            An event is alive when it is not triggered and not processed. That
            is, when it exists in memory without being scheduled. Typically,
            a Process is alive until its last event has been processed and the
            process event itself is to be processed.
            </summary>
        </member>
        <member name="P:SimSharp.Event.IsProcessed">
            <summary>
            An event becomes processed when its callbacks have been executed.
            Events may only be processed once and an exception will be thrown
            if they are to be processed multiple times.
            </summary>
        </member>
        <member name="P:SimSharp.Event.IsTriggered">
            <summary>
            An event becomes triggered when it is placed into the event queue.
            That is, when its callbacks are going to be executed.
            An even that is triggered may later not be failed or retriggered.
            </summary>
        </member>
        <member name="M:SimSharp.Event.Trigger(SimSharp.Event,System.Int32)">
            <summary>
            This method schedules the event right now. It takes the IsOk state
            and uses the <see cref="P:SimSharp.Event.Value"/> of the given <paramref name="@event"/>.
            Thus if the given event fails, this event will also be triggered as
            failing.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the event has already been triggered.
            </exception>
            <remarks>
            The signature of this method allows it to be used as a callback.
            </remarks>
            <param name="event">The event that triggers this event.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.Event.Succeed(System.Object,System.Int32)">
            <summary>
            This method schedules the event right now. It sets IsOk state to true
            and optionally uses also the value. If urgent is given, the event may
            be scheduled as urgent. Urgent events are placed in a separate event
            queue. The callbacks of urgent events are executed before normal events.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the event has already been triggered.
            </exception>
            <param name="value">The value that the event should use.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.Event.Fail(System.Object,System.Int32)">
            <summary>
            This method schedules the event right now. It sets IsOk state to false
            and optionally uses also the value. If urgent is given, the event may
            be scheduled as urgent. Urgent events are placed in a separate event
            queue. The callbacks of urgent events are executed before normal events.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the event has already been triggered.
            </exception>
            <param name="value">The value that the event should use.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.Event.AddCallback(System.Action{SimSharp.Event})">
            <summary>
            This method adds a callback to the list of callbacks. Callbacks will be
            executed in the order they have been added.
            </summary>
            <param name="callback">The callback to execute when the event is being
            processed.</param>
        </member>
        <member name="M:SimSharp.Event.AddCallbacks(System.Collections.Generic.IEnumerable{System.Action{SimSharp.Event}})">
            <summary>
            This method adds a range of callbacks to the list of callbacks. Callbacks
            will be executed in the order they have been added.
            </summary>
            <param name="callbacks">The callbacks to execute when the event is being
            processed.</param>
        </member>
        <member name="M:SimSharp.Event.RemoveCallback(System.Action{SimSharp.Event})">
            <summary>
            This method removes a callback to the list of callbacks.
            </summary>
            <remarks>
            It is not checked if the callback has actually been added before and
            no exception will be thrown if it had not been present.
            </remarks>
            <param name="callback">The callback to remove.</param>
        </member>
        <member name="M:SimSharp.Event.Process">
            <summary>
            This method processes the event, that is, it calls all the callbacks.
            When it finishes it will be marked IsProcessed and cannot be processed
            again.
            </summary>
            <exception cref="T:System.InvalidOperationException">When the event has already
            been processed.</exception>
        </member>
        <member name="T:SimSharp.Process">
            <summary>
            A Process handles the iteration of events. Processes may define steps that
            a certain entity in the simulation has to perform. Each time the process
            should wait it yields an event and will be resumed when that event is processed.
            </summary>
            <remarks>
            Since an iterator method does not have access to its process, the method can
            retrieve the associated Process through the ActiveProcess property of the
            environment. Each Process sets and resets that property during Resume.
            </remarks>
        </member>
        <member name="P:SimSharp.Process.Target">
            <summary>
            Target is the event that is expected to be executed next in the process.
            </summary>
        </member>
        <member name="M:SimSharp.Process.#ctor(SimSharp.Simulation,System.Collections.Generic.IEnumerable{SimSharp.Event},System.Int32)">
            <summary>
            Sets up a new process.
            The process places an initialize event into the event queue which starts
            the process by retrieving events from the generator.
            </summary>
            <param name="environment">The environment in which the process lives.</param>
            <param name="generator">The generator function of the process.</param>
            <param name="priority">The priority if multiple processes are started at the same time.</param>
        </member>
        <member name="M:SimSharp.Process.Interrupt(System.Object,System.Int32)">
            <summary>
            This interrupts a process and causes the IsOk flag to be set to false.
            If a process is interrupted the iterator method needs to call HandleFault()
            before continuing to yield further events.
            </summary>
            <exception cref="T:System.InvalidOperationException">This is thrown in three conditions:
             - If the process has already been triggered.
             - If the process attempts to interrupt itself.
             - If the process continues to yield events despite being faulted.</exception>
            <param name="cause">The cause of the interrupt.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="M:SimSharp.Process.HandleFault">
            <summary>
            This method must be called to reset the IsOk flag of the process back to true.
            The IsOk flag may be set to false if the process waited on an event that failed.
            </summary>
            <remarks>
            In SimPy a faulting process would throw an exception which is then catched and
            chained. In SimSharp catching exceptions from a yield is not possible as a yield
            return statement may not throw an exception.
            If a processes faulted the Value property may indicate a cause for the fault.
            </remarks>
            <returns>True if a faulting situation needs to be handled, false if the process
            is okay and the last yielded event succeeded.</returns>
        </member>
        <member name="M:SimSharp.PseudoRealtimeProcess.#ctor(SimSharp.PseudoRealtimeSimulation,System.Collections.Generic.IEnumerable{SimSharp.Event},System.Int32,System.Double)">
            <summary>
            Sets up a new process.
            The process places an initialize event into the event queue which starts
            the process by retrieving events from the generator.
            </summary>
            <param name="environment">The environment in which the process lives.</param>
            <param name="generator">The generator function of the process.</param>
            <param name="priority">The priority if multiple processes are started at the same time.</param>
            <param name="realtimeScale">A value strictly greater than 0 used to scale real time events (1 = realtime).</param>
        </member>
        <member name="T:SimSharp.Timeout">
            <summary>
            Timeouts are simple events that are executed after a certain timespan has passed.
            </summary>
        </member>
        <member name="M:SimSharp.Timeout.#ctor(SimSharp.Simulation,System.TimeSpan,System.Object,System.Boolean,System.Int32)">
            <summary>
            A timeout is an event that is executed after a certain timespan has passed.
            </summary>
            <remarks>
            Timeout events are scheduled when they are created. They are always triggered
            when they are created.
            </remarks>
            <param name="environment">The environment in which it is scheduled.</param>
            <param name="delay">The timespan for the timeout.</param>
            <param name="value">The value of the timeout.</param>
            <param name="isOk">Whether the timeout should succeed or fail.</param>
            <param name="priority">The priority to rank events at the same time (smaller value = higher priority).</param>
        </member>
        <member name="T:SimSharp.StopSimulationException">
            <summary>
            An exception that is thrown to stop the simulation.
            </summary>
        </member>
        <member name="T:SimSharp.Container">
            <summary>
            A container holds a variable amount of a single continuous entity, e.g. water, coal, grain, etc.
            
            Put and Get are in FIFO order only when they can be satisfied.
            Any put or get that can be satisfied takes precedence.
            Put events that attempt to add more to the Container than there is capacity for and
            Get events that remove more than there is are backlogged.
            </summary>
        </member>
        <member name="T:SimSharp.FilterStore">
            <summary>
            A filter store is similar to a <see cref="T:SimSharp.Store"/>.
            However, in Get it is possible to specify the property of the item wished to retrieve.
            
            FilterStore holds a variable number of individual items.
            Put are always performed in FIFO order. 
            Get are performed in FIFO order only when they match at least one item in the store.
            </summary>
        </member>
        <member name="T:SimSharp.PreemptiveResource">
            <summary>
            A PreemptiveResource is similar to a <see cref="T:SimSharp.PriorityResource"/>. However,
            it may be possible to interrupt a lower-priority user and hand over the resource.
            
            PreemptiveResource holds a fixed amount of anonymous entities.
            Requests are processed in this order: priority, time, preemption, and finally FIFO.
            Releases are processed in FIFO order (usually no simulation time passes for a Release).
            </summary>
            <remarks>
            Working with PreemptiveResource, a process holding a request must always call
            <see cref="M:SimSharp.Process.HandleFault"/> after yielding an event and handle a potential
            interruption.
            </remarks>
        </member>
        <member name="T:SimSharp.PriorityResource">
            <summary>
            A PriorityResource is similar to a <see cref="T:SimSharp.Resource"/>.
            However, it enables prioritizing requests.
            
            PriorityResource holds a fixed number of anonymous entities.
            Requests are processed in order priority first, FIFO second.
            Releases are processed in FIFO order (usually no simulation time passes for a Release).
            </summary>
        </member>
        <member name="T:SimSharp.PriorityStore">
            <summary>
            A PriorityStore is similar to a <see cref="T:SimSharp.Store"/>.
            However, items are removed from the store in order of their priority.
            
            PriorityStore holds a variable number of individual items.
            Put and Get are both processed in strict FIFO order.
            </summary>
        </member>
        <member name="T:SimSharp.Resource">
            <summary>
            A resource holds a fixed number of anonymous entities.
            
            Requests are processed in FIFO order.
            Releases are processed in FIFO order (usually no simulation time passes for a Release).
            </summary>
        </member>
        <member name="T:SimSharp.ResourcePool">
            <summary>
            A ResourcePool is a crossover between a <see cref="T:SimSharp.Resource"/> and a <see cref="T:SimSharp.Store"/>.
            There is a fixed number of non-anonymous resources.
            
            Requests are performed in FIFO order only when they match at least one resource in the pool.
            Releases are processed in FIFO order (usually no simulation time passes for a Release).
            </summary>
        </member>
        <member name="T:SimSharp.Store">
            <summary>
            The store holds a variable number of individual items.
            The items are removed from the store in FIFO order.
            
            Put are processed in FIFO order.
            Get are processed in FIFO order.
            </summary>
        </member>
        <member name="T:SimSharp.Pcg">
            <summary>
            PCG (Permuted Congruential Generator) is a C# port from C the base PCG generator
            presented in "PCG: A Family of Simple Fast Space-Efficient Statistically Good
            Algorithms for Random Number Generation" by Melissa E. O'Neill. The code follows closely the one 
            made available by O'Neill at her site: http://www.pcg-random.org/download.html
            To understand how exactly this generator works read this:
            http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf 
            </summary>
        </member>
        <member name="M:SimSharp.PcgSeed.TimeBasedSeed">
            <summary>
            Provides a time-dependent seed value, matching the default behavior of System.Random.
            </summary>
        </member>
        <member name="M:SimSharp.PcgSeed.GuidBasedSeed">
            <summary>
            Provides a seed based on time and unique GUIDs.
            </summary>
        </member>
    </members>
</doc>
